<?php

/*
 * This file is part of the Silence package.
 *
 * (c) Andrew Gebrich <an_gebrich@outlook.com>
 *
 * For the full copyright and license information, please view the LICENSE file that was distributed with this
 * source code.
 */

declare(strict_types=1);

namespace Silence\Http\Handlers;

use Psr\EventDispatcher\EventDispatcherInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Silence\Event\EventFactoryInterface;
use Silence\Http\HandlerResolvers\HandlerResolverInterface;
use Silence\Routing\RouteNotFound;
use Silence\Routing\RouterInterface;

/**
 * Implementation of an HTTP request handler that handles routing within the application.
 */
final readonly class RouteHandler implements RouteHandlerInterface
{
    public function __construct(
        private RouterInterface $router,
        private HandlerResolverInterface $handlerResolver,
        private MiddlewareRunnerFactoryInterface $middlewareRunnerFactory,
        private RequestHandlerInterface $fallbackHandler,
        private EventDispatcherInterface $dispatcher,
        private EventFactoryInterface $eventFactory,
    ) {}

    /**
     * Resolves the current route using the router and processes the request accordingly.
     *
     * - Injects route parameters as request attributes.
     * - Dispatches events for successful or failed route resolution.
     * - Delegates request handling to the route-specific middleware stack and final handler.
     * - Falls back to the fallback handler if the route cannot be resolved.
     *
     * @param ServerRequestInterface $request The incoming HTTP request.
     * @return ResponseInterface The response generated by the matched route or fallback handler.
     */
    public function handle(ServerRequestInterface $request): ResponseInterface
    {
        try {
            $resolved = $this->router->resolve($request);
            $handler = $this->handlerResolver->resolve($resolved);

            foreach ($resolved->parameters as $name => $param) {
                $request = $request->withAttribute($name, $param);
            }

            $this->dispatcher->dispatch($this->eventFactory->routeResolved($resolved, $request));

            $routeMiddlewares = $resolved->route->getMiddlewares();

            return $this->middlewareRunnerFactory
                ->create($routeMiddlewares, $handler)
                ->handle($request)
            ;
        } catch (RouteNotFound) {
            $this->dispatcher->dispatch($this->eventFactory->routeNotFound($request));

            return $this->fallbackHandler->handle($request);
        }
    }
}
